<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#f0f0f0">
    <meta name="description" content="A customizable grid application with ordering features">
    <title>8x6 Grid with Order Feature</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='192' height='192' viewBox='0 0 192 192'%3E%3Crect width='192' height='192' fill='%234CAF50' rx='32' ry='32'/%3E%3Ctext x='96' y='120' font-family='Arial, sans-serif' font-size='88' font-weight='bold' text-anchor='middle' fill='white'%3EG%3C/text%3E%3C/svg%3E">
    <style>
        :root {
            /* Theme variables - light mode defaults */
            --bg-color: white;
            --text-color: black;
            --header-bg: #f0f0f0;
            --header-border: #ccc;
            --btn-bg: #ddd;
            --btn-border: #ccc;
            --dropdown-bg: white;
            --dropdown-border: #ccc;
            --cell-border: black;
            --input-bg: white;
            --hover-bg: #f0f0f0;
            --item-bg: white;
            --item-border: #ddd;
            --panel-bg: #f5f5f5;
            --panel-header-bg: #eee;
            --panel-header-border: #ddd;
            --modal-bg: white;
            --modal-shadow: rgba(0, 0, 0, 0.2);
            --overlay-bg: rgba(0, 0, 0, 0.5);
            --selected-bg: rgba(76, 175, 80, 0.3);
            --expired-bg: rgba(220, 53, 69, 0.3);
            --soon-bg: rgba(255, 193, 7, 0.3);
            --green-color: #4CAF50;
            --red-color: #dc3545;
            --yellow-color: #FFC107;
            --blue-color: #007BFF;
            --purple-color: #6200ee;
        }

        /* Dark mode theme variables */
        body.dark-mode {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --header-bg: #1e1e1e;
            --header-border: #333;
            --btn-bg: #333;
            --btn-border: #444;
            --dropdown-bg: #222;
            --dropdown-border: #444;
            --cell-border: #777;
            --input-bg: #222;
            --hover-bg: #2a2a2a;
            --item-bg: #1e1e1e;
            --item-border: #333;
            --panel-bg: #1a1a1a;
            --panel-header-bg: #252525;
            --panel-header-border: #333;
            --modal-bg: #222;
            --modal-shadow: rgba(0, 0, 0, 0.4);
            --overlay-bg: rgba(0, 0, 0, 0.7);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        header {
            background-color: var(--header-bg);
            padding: 10px;
            border-bottom: 1px solid var(--header-border);
            display: flex;
            align-items: center;
            height: 40px;
        }

        .page-controls {
            display: flex;
            width: 100%;
            align-items: center;
            gap: 10px;
        }

        .page-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-grow: 1;
        }

        .page-label {
            font-weight: bold;
        }

        .page-dropdown {
            position: relative;
            flex-grow: 1;
            max-width: 300px;
        }

        .current-page {
            width: 100%;
            padding: 8px;
            background-color: var(--dropdown-bg);
            border: 1px solid var(--dropdown-border);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            color: var(--text-color);
            -webkit-tap-highlight-color: transparent;
        }

        .current-page::after {
            content: 'â–¼';
            font-size: 0.8em;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--dropdown-bg);
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--dropdown-border);
            border-top: none;
            border-radius: 0 0 4px 4px;
            z-index: 100;
            box-shadow: 0 4px 8px var(--modal-shadow);
        }

        .dropdown-content.show {
            display: block;
        }

        .page-option {
            padding: 8px;
            cursor: pointer;
            color: var(--text-color);
            -webkit-tap-highlight-color: transparent;
        }

        .page-option:hover {
            background-color: var(--hover-bg);
        }

        .rename-button,
        .toggle-button {
            background-color: var(--btn-bg);
            padding: 8px 12px;
            border: 1px solid var(--btn-border);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-color);
            -webkit-tap-highlight-color: transparent;
        }

        .rename-input {
            padding: 8px;
            border: 1px solid var(--dropdown-border);
            border-radius: 4px;
            margin-right: 10px;
            background-color: var(--dropdown-bg);
            color: var(--text-color);
        }

        .wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 0.5px solid var(--cell-border);
        }

        .row {
            display: flex;
            flex: 1;
            border-bottom: 0.5px solid var(--cell-border);
        }

        .row:last-child {
            border-bottom: none;
        }

        .cell {
            flex: 1;
            border-right: 0.5px solid var(--cell-border);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
            margin: 0;
        }

        .cell:last-child {
            border-right: none;
        }

        .cell input {
            width: 100%;
            height: 100%;
            border: none;
            padding: 0;
            margin: 0;
            text-align: center;
            background: none;
            font-weight: bold;
            box-sizing: border-box;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            color: var(--text-color);
        }

        .cell input:focus {
            outline: none;
            background: var(--hover-bg);
            -webkit-appearance: none;
            appearance: none;
        }

        .cell.selected, .subcell.selected {
            background-color: var(--selected-bg) !important;
            position: relative;
        }

        /* Order mode styles */
        .order-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .order-toggle {
            padding: 8px 12px;
            background-color: var(--btn-bg);
            border: 1px solid var(--btn-border);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-color);
            -webkit-tap-highlight-color: transparent;
        }

        .order-toggle.active {
            background-color: var(--green-color);
            color: white;
        }

        #splitCellButton.active {
            background-color: var(--blue-color);
            color: white;
        }

        .order-number {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: var(--green-color);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }

        /* Split cell styles */
        .cell.split {
            flex-direction: column;
            padding: 0;
        }

        .split-mode .cell.split {
            cursor: pointer;
        }

        .subcell {
            width: 100%;
            height: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .subcell:first-child {
            border-bottom: 0.5px solid var(--cell-border);
        }

        .subcell input {
            width: 100%;
            height: 100%;
            border: none;
            padding: 0;
            margin: 0;
            text-align: center;
            background: none;
            font-weight: bold;
            box-sizing: border-box;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            color: var(--text-color);
        }

        /* Main container with order list panel */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Order list panel styles */
        .order-panel {
            width: 0;
            background-color: var(--panel-bg);
            border-left: 1px solid var(--header-border);
            overflow-y: auto;
            transition: width 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .order-panel.show {
            width: 250px;
        }

        .order-panel-header {
            background-color: var(--panel-header-bg);
            padding: 10px;
            font-weight: bold;
            border-bottom: 1px solid var(--panel-header-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .order-panel-close {
            cursor: pointer;
            font-size: 16px;
            -webkit-tap-highlight-color: transparent;
        }

        .order-panel-items {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .order-panel-item {
            background-color: var(--item-bg);
            border: 1px solid var(--item-border);
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
        }

        .order-panel-item:hover {
            background-color: var(--hover-bg);
        }

        .order-panel-item span.item-number {
            background-color: var(--green-color);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-size: 12px;
        }

        .order-panel-empty {
            padding: 15px;
            color: #666;
            text-align: center;
        }

        /* Expiration mode specific styles */
        #expirationToggle.active {
            background-color: var(--yellow-color);
            color: black;
        }

        .section-header {
            font-weight: bold;
            padding: 8px;
            margin-top: 5px;
        }

        .expired-header {
            background-color: #f8d7da;
            color: #721c24;
        }

        .soon-header {
            background-color: #fff3cd;
            color: #856404;
        }

        /* Date input modal styles */
        .date-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-bg);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .date-modal {
            background-color: var(--modal-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--modal-shadow);
            padding: 20px;
            width: 300px;
            max-width: 90%;
        }

        .date-modal h3 {
            margin-top: 0;
            color: var(--text-color);
        }

        .date-input-container {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }

        .date-input-container select {
            padding: 8px;
            border: 1px solid var(--dropdown-border);
            border-radius: 4px;
            text-align: center;
            font-size: 16px;
            background-color: var(--dropdown-bg);
            color: var(--text-color);
            cursor: pointer;
        }

        .date-input-container span {
            margin: 0 10px;
            font-size: 18px;
            font-weight: bold;
        }

        #monthSelect {
            width: 120px;
        }

        #yearSelect {
            width: 100px;
        }

        .date-modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }

        .date-modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        #confirmDateBtn {
            background-color: var(--green-color);
            color: white;
        }

        #cancelDateBtn {
            background-color: var(--btn-bg);
            color: var(--text-color);
        }

        /* Format input modal styles */
        .format-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--overlay-bg);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .format-modal {
            background-color: var(--modal-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--modal-shadow);
            padding: 20px;
            width: 300px;
            max-width: 90%;
        }

        .format-modal h3 {
            margin-top: 0;
            color: var(--text-color);
        }

        .format-input-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 15px 0;
            gap: 5px;
        }

        .format-input-container button {
            width: 40px;
            height: 40px;
            border: 1px solid var(--btn-border);
            border-radius: 4px;
            background-color: var(--btn-bg);
            color: var(--text-color);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        .format-input-container button:hover {
            background-color: var(--hover-bg);
        }

        .format-input-container input {
            padding: 8px;
            border: 1px solid var(--dropdown-border);
            border-radius: 4px;
            text-align: center;
            font-size: 16px;
            background-color: var(--dropdown-bg);
            color: var(--text-color);
            width: 80px;
        }

        #bcBtn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--btn-border);
            border-radius: 4px;
            background-color: var(--btn-bg);
            color: var(--text-color);
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 5px;
            -webkit-tap-highlight-color: transparent;
        }

        #bcBtn:hover {
            background-color: var(--hover-bg);
        }

        .bc-dropdown {
            display: none;
            position: absolute;
            right: 20px;
            top: 180px;
            background-color: var(--dropdown-bg);
            border: 1px solid var(--dropdown-border);
            border-radius: 4px;
            box-shadow: 0 4px 8px var(--modal-shadow);
            z-index: 2000;
        }

        .bc-dropdown.show {
            display: block;
        }

        .bc-option {
            padding: 8px 16px;
            cursor: pointer;
            color: var(--text-color);
            -webkit-tap-highlight-color: transparent;
        }

        .bc-option:hover {
            background-color: var(--hover-bg);
        }

        .value-display {
            margin-bottom: 10px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }

        /* Add expiration date section to format modal */
        .expiration-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--dropdown-border);
        }

        .expiration-section h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .expiration-checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .expiration-date-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .expiration-date-container select {
            padding: 6px;
            border: 1px solid var(--dropdown-border);
            border-radius: 4px;
            background-color: var(--dropdown-bg);
            color: var(--text-color);
        }

        .expiration-date-container span {
            margin: 0 8px;
        }

        #formatExpirationMonth {
            width: 100px;
        }

        #formatExpirationYear {
            width: 80px;
        }

        .format-modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }

        .format-modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        #confirmFormatBtn {
            background-color: var(--green-color);
            color: white;
        }

        #cancelFormatBtn {
            background-color: var(--btn-bg);
            color: var(--text-color);
        }

        /* Dark mode toggle button */
        #darkModeToggle {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #darkModeToggle.active {
            background-color: var(--purple-color);
            color: white;
        }

        .format-example {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }

        .format-error {
            color: var(--red-color);
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }
    </style>
</head>

<body>
    <header>
        <div class="page-controls">
            <div class="page-selector">
                <div class="page-dropdown">
                    <div class="current-page" id="currentPage">Page 1</div>
                    <div class="dropdown-content" id="pageDropdown"></div>
                </div>
            </div>
            <div class="order-controls">
                <button class="rename-button" id="splitCellButton">Split Cell</button>
                <button class="order-toggle" id="orderToggle">Order Mode</button>
                <button class="toggle-button" id="darkModeToggle">Dark Mode</button>
                <button class="toggle-button" id="exitButton" style="background-color: var(--red-color); color: white;">Exit App</button>
            </div>
        </div>
    </header>
    <div class="main-container">
        <div class="wrapper" id="grid"></div>
        <div class="order-panel" id="orderPanel">
            <div class="order-panel-header">
                <span>Ordered Items</span>
                <span class="order-panel-close" id="orderPanelClose">Ã—</span>
            </div>
            <div class="order-panel-items" id="orderPanelItems">
                <!-- Order items will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Date input modal -->
    <div class="date-modal-overlay" id="dateModalOverlay">
        <div class="date-modal">
            <h3>Set Expiration Date</h3>
            <p>Enter expiration date in MM/YYYY format</p>
            <div class="date-input-container">
                <select id="monthSelect">
                    <option value="" disabled selected>Month</option>
                    <option value="01">1</option>
                    <option value="02">2</option>
                    <option value="03">3</option>
                    <option value="04">4</option>
                    <option value="05">5</option>
                    <option value="06">6</option>
                    <option value="07">7</option>
                    <option value="08">8</option>
                    <option value="09">9</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                </select>
                <span>/</span>
                <select id="yearSelect">
                    <option value="" disabled selected>Year</option>
                    <!-- Year options will be populated by JavaScript -->
                </select>
            </div>
            <div class="date-modal-buttons">
                <button id="cancelDateBtn">Cancel</button>
                <button id="confirmDateBtn">Confirm</button>
            </div>
        </div>
    </div>

        <!-- Format input modal for Edit mode -->
        <div class="format-modal-overlay" id="formatModalOverlay">
            <div class="format-modal">
                <div class="value-display" id="valueDisplay" style="margin: 25px 0; font-size: 32px; text-align: center;">+0.00</div>
                <div style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
                    <div class="format-input-container" style="gap: 10px; justify-content: center;">
                        <button id="decrementBtn" style="width: 50px; height: 50px; font-size: 24px;">-</button>
                        <input type="text" id="formatInput" placeholder="+/-x.xx" readonly style="width: 100px; height: 50px; font-size: 20px;">
                        <button id="incrementBtn" style="width: 50px; height: 50px; font-size: 24px;">+</button>
                    </div>
                    <div style="text-align: center; margin: 10px 0;">
                        <button id="bcBtn" style="width: 80px; height: 50px; font-size: 18px;">BC</button>
                        <div class="bc-dropdown" id="bcDropdown" style="position: absolute; left: 50%; transform: translateX(-50%); margin-top: 5px; width: 120px;">
                    <div class="bc-option" data-value="8.3">8.3</div>
                    <div class="bc-option" data-value="8.4">8.4</div>
                    <div class="bc-option" data-value="8.5">8.5</div>
                    <div class="bc-option" data-value="8.6">8.6</div>
                    <div class="bc-option" data-value="9.0">9.0</div>
                </div>
            </div>
            <div class="format-error" id="formatError">Please enter a value in the format: +/-x.xx</div>

            <!-- Add expiration date section -->
            <div class="expiration-section" style="margin-top: 25px;">
                <h4>Expiration Date</h4>
                <div class="expiration-date-container">
                    <select id="formatExpirationMonth">
                        <option value="" disabled selected>Month</option>
                        <option value="01">1</option>
                        <option value="02">2</option>
                        <option value="03">3</option>
                        <option value="04">4</option>
                        <option value="05">5</option>
                        <option value="06">6</option>
                        <option value="07">7</option>
                        <option value="08">8</option>
                        <option value="09">9</option>
                        <option value="10">10</option>
                        <option value="11">11</option>
                        <option value="12">12</option>
                    </select>
                    <span>/</span>
                    <select id="formatExpirationYear">
                        <option value="" disabled selected>Year</option>
                        <!-- Will be populated by JavaScript -->
                    </select>
                </div>
            </div>

            <div class="format-modal-buttons">
                <button id="cancelFormatBtn">Cancel</button>
                <button id="confirmFormatBtn" disabled>Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // Data structure for pages with default data
        const defaultPages = Array(16).fill().map((_, i) => ({
            name: `Page ${i + 1}`,
            data: Array(6).fill().map(() => Array(8).fill(''))
        }));

        // Fill initial data for page 1 (only used if no data in localStorage)
        for (let i = 0; i < 6; i++) {
            for (let j = 0; j < 8; j++) {
                defaultPages[0].data[i][j] = (i * 8 + j + 1).toString();
            }
        }

        // Initialize variables - these will be populated from localStorage if available
        let pages = JSON.parse(JSON.stringify(defaultPages)); // Deep copy
        let currentPageIndex = 0;
        let isRenaming = false;
        let orderItems = [];
        let expirationItems = [];
        let splitCells = []; // Track split cells

        // Mode state variables - only one can be true at a time
        let orderMode = false;
        let expirationMode = false;
        let splitCellMode = false;
        let darkMode = false;
        
        // Cache lookup maps for faster checks
        let orderLookup = {};
        let expirationLookup = {};
        let splitCellLookup = {};
        
        // Current modal state
        let currentCell = null;
        let currentCellData = null;
        let currentValueNum = 0;
        let currentBCValue = null;
        
        // Local storage key
        const STORAGE_KEY = 'gridLayoutAppData';
        const DARK_MODE_KEY = 'gridLayoutDarkMode';
        
        // Cache DOM elements for better performance
        const els = {
            grid: document.getElementById('grid'),
            currentPage: document.getElementById('currentPage'),
            pageDropdown: document.getElementById('pageDropdown'),
            orderToggle: document.getElementById('orderToggle'),
            orderPanel: document.getElementById('orderPanel'),
            orderPanelItems: document.getElementById('orderPanelItems'),
            orderPanelClose: document.getElementById('orderPanelClose'),
            splitCellButton: document.getElementById('splitCellButton'),
            dateModalOverlay: document.getElementById('dateModalOverlay'),
            monthSelect: document.getElementById('monthSelect'),
            yearSelect: document.getElementById('yearSelect'),
            confirmDateBtn: document.getElementById('confirmDateBtn'),
            cancelDateBtn: document.getElementById('cancelDateBtn'),
            formatModalOverlay: document.getElementById('formatModalOverlay'),
            formatInput: document.getElementById('formatInput'),
            formatError: document.getElementById('formatError'),
            confirmFormatBtn: document.getElementById('confirmFormatBtn'),
            cancelFormatBtn: document.getElementById('cancelFormatBtn'),
            formatExpirationMonth: document.getElementById('formatExpirationMonth'),
            formatExpirationYear: document.getElementById('formatExpirationYear'),
            valueDisplay: document.getElementById('valueDisplay'),
            incrementBtn: document.getElementById('incrementBtn'),
            decrementBtn: document.getElementById('decrementBtn'),
            bcBtn: document.getElementById('bcBtn'),
            bcDropdown: document.getElementById('bcDropdown'),
            darkModeToggle: document.getElementById('darkModeToggle')
        };

        // Function to save all data to localStorage - batched to reduce writes
        function saveToLocalStorage() {
            try {
                const dataToSave = {
                    pages: pages,
                    currentPageIndex: currentPageIndex,
                    orderItems: orderItems,
                    expirationItems: expirationItems,
                    splitCells: splitCells
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        // Function to load data from localStorage
        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (savedData) {
                    const parsedData = JSON.parse(savedData);

                    // Update all application state variables
                    pages = parsedData.pages || JSON.parse(JSON.stringify(defaultPages));
                    currentPageIndex = parsedData.currentPageIndex || 0;
                    orderItems = parsedData.orderItems || [];
                    expirationItems = parsedData.expirationItems || [];
                    splitCells = parsedData.splitCells || [];

                    // Build lookup tables for faster searches
                    rebuildLookupTables();
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                // Fallback to default data if there's an error
                pages = JSON.parse(JSON.stringify(defaultPages));
                currentPageIndex = 0;
                orderItems = [];
                expirationItems = [];
                splitCells = [];
                rebuildLookupTables();
            }
        }
        
        // Build lookup tables for faster item checking
        function rebuildLookupTables() {
            // Reset all lookup tables
            orderLookup = {};
            expirationLookup = {};
            splitCellLookup = {};
            
            // Build order lookup
            orderItems.forEach((item, index) => {
                const key = getItemKey(item);
                orderLookup[key] = index;
            });
            
            // Build expiration lookup
            expirationItems.forEach((item, index) => {
                const key = getItemKey(item);
                expirationLookup[key] = index;
            });
            
            // Build split cell lookup
            splitCells.forEach(item => {
                const key = `${item.page}-${item.row}-${item.col}`;
                splitCellLookup[key] = true;
            });
        }
        
        // Get a unique key for an item
        function getItemKey(item) {
            return `${item.page}-${item.row}-${item.col}${item.part ? '-' + item.part : ''}`;
        }
        
        // Check if a cell is in order list - O(1) lookup instead of O(n) array search
        function isInOrderList(page, row, col, part) {
            const key = `${page}-${row}-${col}${part ? '-' + part : ''}`;
            return orderLookup[key] !== undefined;
        }
        
        // Check if a cell has expiration date - O(1) lookup instead of O(n) array search
        function isInExpirationList(page, row, col, part) {
            const key = `${page}-${row}-${col}${part ? '-' + part : ''}`;
            return expirationLookup[key] !== undefined;
        }
        
        // Check if a cell is split - O(1) lookup instead of O(n) array search
        function isCellSplit(page, row, col) {
            const key = `${page}-${row}-${col}`;
            return splitCellLookup[key] === true;
        }
        
        // Setup dropdown toggle function
        function setupDropdownToggle() {
            // Click to show dropdown, double-click to rename
            els.currentPage.addEventListener('click', e => {
                e.stopPropagation();
                els.pageDropdown.classList.toggle('show');
            });

            // Double-click to rename
            els.currentPage.addEventListener('dblclick', e => {
                e.stopPropagation();
                startRenaming();
            });

            // Hover effects for rename
            els.currentPage.addEventListener('mouseenter', function() {
                this.style.cursor = 'pointer';
                this.title = 'Click to show pages, double-click to rename';
            });

            els.currentPage.addEventListener('mouseleave', function() {
                this.style.cursor = '';
                this.title = '';
            });
        }

        // Centralized mode management function
        function setActiveMode(mode) {
            // Check if we're exiting expiration mode
            if (expirationMode && mode !== 'expiration') {
                clearExpirationVisualIndicators();
            }

            // First, deactivate all modes
            orderMode = false;
            expirationMode = false;
            splitCellMode = false;

            // Update all button states
            els.orderToggle.classList.remove('active');
            els.splitCellButton.classList.remove('active');

            // Reset button texts
            els.orderToggle.textContent = 'Order Mode';
            els.splitCellButton.textContent = 'Split Cell';

            // Hide panels
            els.orderPanel.classList.remove('show');

            // Reset cursor
            document.documentElement.style.cursor = 'default';

            // Remove split-mode class
            els.grid.classList.remove('split-mode');

            // Now activate the requested mode
            switch (mode) {

                case 'order':
                    orderMode = true;
                    els.orderToggle.classList.add('active');
                    els.orderToggle.textContent = 'Exit Order Mode';
                    document.documentElement.style.cursor = 'pointer';

                    // Show order panel
                    els.orderPanel.classList.add('show');
                    els.orderPanel.querySelector('.order-panel-header span:first-child').textContent = 'Ordered Items';
                    updateOrderPanel();
                    break;

                case 'expiration':
                    expirationMode = true;
                    document.documentElement.style.cursor = 'pointer';

                    // Show expiration panel
                    els.orderPanel.classList.add('show');
                    els.orderPanel.querySelector('.order-panel-header span:first-child').textContent = 'Expiring Items';
                    updateExpirationPanel();

                    // Restore expiration visual indicators when entering expiration mode
                    restoreExpirationVisualIndicators();
                    break;

                case 'split':
                    splitCellMode = true;
                    els.splitCellButton.classList.add('active');
                    els.splitCellButton.textContent = 'Exit Split Mode';
                    document.documentElement.style.cursor = 'pointer';

                    // Add split-mode class for visual cues
                    els.grid.classList.add('split-mode');
                    break;

                default:
                    // No mode active
                    break;
            }
        }

        // Create the grid - uses event delegation for efficiency
        function createGrid() {
            els.grid.innerHTML = '';
            const currentPage = pages[currentPageIndex];
            const fragment = document.createDocumentFragment(); // Use fragment for better performance

            for (let i = 0; i < 6; i++) {
                const row = document.createElement('div');
                row.className = 'row';

                for (let j = 0; j < 8; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;

                    // Check if cell is split - using fast lookup
                    const isSplit = isCellSplit(currentPageIndex, i, j);

                    if (isSplit) {
                        // This is a split cell
                        cell.classList.add('split');

                        // Create top subcell
                        const topSubcell = createSubcell(i, j, 'top', currentPage.data[i][j].top || '');
                        cell.appendChild(topSubcell);

                        // Create bottom subcell
                        const bottomSubcell = createSubcell(i, j, 'bottom', currentPage.data[i][j].bottom || '');
                        cell.appendChild(bottomSubcell);

            // Add click handler to the entire cell for merging in split mode
                        cell.addEventListener('click', function(e) {
                            // Only process if in split mode
                            if (splitCellMode) {
                                e.preventDefault();
                                e.stopPropagation();

                                const row = parseInt(this.dataset.row);
                                const col = parseInt(this.dataset.col);

                                // Debounce the click to prevent double processing
                                if (!this.mergeInProgress) {
                                    this.mergeInProgress = true;
                                    splitCell(this, row, col);
                                    setTimeout(() => {
                                        this.mergeInProgress = false;
                                    }, 300);
                                }
                            }
                        }, true);
                    } else {
                        // Regular non-split cell
                        const input = document.createElement('input');
                        input.value = typeof currentPage.data[i][j] === 'object' ?
                            currentPage.data[i][j].top || '' :
                            currentPage.data[i][j];
                        input.dataset.row = i;
                        input.dataset.col = j;

                        // Always keep input read-only but clickable for format modal
                        input.readOnly = true;
                        input.style.pointerEvents = 'auto';

                        cell.appendChild(input);

                        // Check for order markers on cell - using fast lookup
                        if (isInOrderList(currentPageIndex, i, j)) {
                            cell.classList.add('selected');

                            const orderNumber = document.createElement('div');
                            orderNumber.className = 'order-number';
                            const orderIndex = orderLookup[`${currentPageIndex}-${i}-${j}`];
                            orderNumber.textContent = orderIndex + 1;
                            cell.appendChild(orderNumber);
                        }

                        // Check for expiration markers on cell - using fast lookup
                        if (isInExpirationList(currentPageIndex, i, j)) {
                            const expirationIndex = expirationLookup[`${currentPageIndex}-${i}-${j}`];
                            const expirationItem = expirationItems[expirationIndex];
                            
                            // Set expiration background
                            if (isItemExpired(expirationItem)) {
                                cell.style.backgroundColor = "var(--expired-bg)";
                            } else if (isItemDueSoon(expirationItem)) {
                                cell.style.backgroundColor = "var(--soon-bg)";
                            }

                            // Only add calendar icon in expiration mode
                            if (expirationMode) {
                                const expirationLabel = document.createElement('div');
                                expirationLabel.className = 'order-number';
                                expirationLabel.textContent = "ðŸ“†";
                                expirationLabel.title = expirationItem.expirationDate;
                                expirationLabel.style.backgroundColor = isItemExpired(expirationItem) ? 
                                    "var(--red-color)" : "var(--yellow-color)";
                                cell.appendChild(expirationLabel);
                            }
                        }
                    }

                    row.appendChild(cell);
                }

                fragment.appendChild(row);
            }
            
            els.grid.appendChild(fragment);
            
            // Use event delegation for grid interactions instead of individual listeners
            els.grid.addEventListener('click', handleGridClick);
        }
        
        // Create a subcell element with all its properties
        function createSubcell(row, col, part, value) {
            const subcell = document.createElement('div');
            subcell.className = 'subcell';
            subcell.dataset.row = row;
            subcell.dataset.col = col;
            subcell.dataset.part = part;

            const input = document.createElement('input');
            input.value = value;
            input.dataset.row = row;
            input.dataset.col = col;
            input.dataset.part = part;

            // Always keep input read-only but clickable for format modal
            input.readOnly = true;
            input.style.pointerEvents = 'auto';

            subcell.appendChild(input);

            // Check for order markers - using fast lookup
            if (isInOrderList(currentPageIndex, row, col, part)) {
                subcell.classList.add('selected');

                const orderNumber = document.createElement('div');
                orderNumber.className = 'order-number';
                const orderIndex = orderLookup[`${currentPageIndex}-${row}-${col}-${part}`];
                orderNumber.textContent = orderIndex + 1;
                subcell.appendChild(orderNumber);
            }

            // Check for expiration markers - using fast lookup
            if (isInExpirationList(currentPageIndex, row, col, part)) {
                const expirationIndex = expirationLookup[`${currentPageIndex}-${row}-${col}-${part}`];
                const expirationItem = expirationItems[expirationIndex];
                
                // Set expiration background
                if (isItemExpired(expirationItem)) {
                    subcell.style.backgroundColor = "var(--expired-bg)";
                } else if (isItemDueSoon(expirationItem)) {
                    subcell.style.backgroundColor = "var(--soon-bg)";
                }

                // Only add the calendar icon if in expiration mode
                if (expirationMode) {
                    const expirationLabel = document.createElement('div');
                    expirationLabel.className = 'order-number';
                    expirationLabel.textContent = "ðŸ“†";
                    expirationLabel.title = expirationItem.expirationDate;
                    expirationLabel.style.backgroundColor = isItemExpired(expirationItem) ? 
                        "var(--red-color)" : "var(--yellow-color)";
                    subcell.appendChild(expirationLabel);
                }
            }

            return subcell;
        }
        
        // Event delegation handler for grid clicks
        function handleGridClick(e) {
            // Find the clicked cell or subcell
            let target = e.target;
            let isInput = target.tagName === 'INPUT';
            let isCell = target.classList.contains('cell');
            let isSubcell = target.classList.contains('subcell');
            
            // If input was clicked, get its parent
            if (isInput) {
                target = target.parentElement;
                isCell = target.classList.contains('cell');
                isSubcell = target.classList.contains('subcell');
            }
            
            // Handle cell click
            if (isCell && !target.classList.contains('split')) {
                handleCellClick(e, target);
            }
            // Handle subcell click
            else if (isSubcell) {
                handleSubcellClick(e, target);
            }
            // Handle split cell click (for merging)
            else if (isCell && target.classList.contains('split') && splitCellMode) {
                const row = parseInt(target.dataset.row);
                const col = parseInt(target.dataset.col);
                splitCell(target, row, col);
            }
        }

        // Cell click handler function
        function handleCellClick(e, cell) {
            e.preventDefault();
            e.stopPropagation();

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // Get cell value handling both string and object cases
            let cellValue;
            if (typeof pages[currentPageIndex].data[row][col] === 'object') {
                cellValue = pages[currentPageIndex].data[row][col].top || '';
            } else {
                cellValue = pages[currentPageIndex].data[row][col];
            }

            // Split cell mode
            if (splitCellMode) {
                splitCell(cell, row, col);
                return;
            }

            // Split cell mode
            if (splitCellMode) {
                splitCell(cell, row, col);
                return;
            }

            // Show format modal by default unless in a special mode
            if (!orderMode && !expirationMode && !splitCellMode) {
                showFormatModal(cell, row, col);
                return;
            }

            // Handle order and expiration modes
            if (orderMode) {
                handleOrderModeClick(cell, row, col, cellValue);
            }

            if (expirationMode) {
                handleExpirationModeClick(cell, row, col, cellValue);
            }
        }

        // Subcell click handler function
        function handleSubcellClick(e, subcell) {
            e.preventDefault();
            e.stopPropagation();

            const row = parseInt(subcell.dataset.row);
            const col = parseInt(subcell.dataset.col);
            const part = subcell.dataset.part;

            let cellValue;
            if (typeof pages[currentPageIndex].data[row][col] === 'object') {
                cellValue = pages[currentPageIndex].data[row][col][part] || '';
            } else {
                cellValue = '';
            }

            // Show format modal by default unless in a special mode
            if (!orderMode && !expirationMode) {
                showFormatModal(subcell, row, col, part);
                return;
            }

            // Order mode handling for subcells
            if (orderMode) {
                const orderIndex = orderItems.findIndex(item =>
                    item.page === currentPageIndex &&
                    item.row === row &&
                    item.col === col &&
                    item.part === part
                );

                if (orderIndex === -1) {
                    // Add to order list
                    const newItem = {
                        page: currentPageIndex,
                        pageName: pages[currentPageIndex].name,
                        row,
                        col,
                        part,
                        value: cellValue
                    };

                    orderItems.push(newItem);
                    subcell.classList.add('selected');

                    const orderNumber = document.createElement('div');
                    orderNumber.className = 'order-number';
                    orderNumber.textContent = orderItems.length;
                    subcell.appendChild(orderNumber);
                    
                    // Update lookup tables
                    rebuildLookupTables();
                    saveToLocalStorage();

                    // Update panel
                    if (els.orderPanel.classList.contains('show')) {
                        updateOrderPanel();
                    }
                } else {
                    // Remove from order list
                    orderItems.splice(orderIndex, 1);

                    // Find and remove the corresponding item in the order panel
                    const panelItem = document.querySelector(`.order-panel-item[data-row="${row}"][data-col="${col}"][data-part="${part}"]`);
                    if (panelItem && panelItem.parentNode) {
                        // Remove item immediately without animation
                        panelItem.parentNode.removeChild(panelItem);
                    }

                    // Remove selected class if no expiration
                    if (!isInExpirationList(currentPageIndex, row, col, part)) {
                        subcell.classList.remove('selected');
                        subcell.style.backgroundColor = '';
                    }

                    // Remove order number
                    const orderNumbers = subcell.querySelectorAll('.order-number');
                    orderNumbers.forEach(num => {
                        if (num.textContent !== "ðŸ“†") {
                            subcell.removeChild(num);
                        }
                    });

                    // Update lookup tables
                    rebuildLookupTables();
                    updateOrderNumbers();
                    saveToLocalStorage();

                    // Update panel
                    if (els.orderPanel.classList.contains('show')) {
                        updateOrderPanel();
                    }
                }
            }

            // Expiration mode handling for subcells
            if (expirationMode) {
                const expirationIndex = expirationItems.findIndex(item =>
                    item.page === currentPageIndex &&
                    item.row === row &&
                    item.col === col &&
                    item.part === part
                );

                if (expirationIndex === -1) {
                    // Show date modal for this subcell
                    showDateModal(subcell, row, col, part, cellValue);
                } else {
                    // Remove from expiration list
                    expirationItems.splice(expirationIndex, 1);
                    
                    // Update lookup tables
                    rebuildLookupTables();

                    // Only remove styling if no order
                    if (!isInOrderList(currentPageIndex, row, col, part)) {
                        subcell.style.backgroundColor = '';
                        subcell.classList.remove('selected');
                    }

                    // Remove expiration markers
                    const markers = subcell.querySelectorAll('.order-number');
                    markers.forEach(marker => {
                        if (marker.textContent === "ðŸ“†") {
                            subcell.removeChild(marker);
                        }
                    });

                    updateExpirationPanel();
                    saveToLocalStorage();
                }
            }
        }

        // Split cell function
        function splitCell(cell, row, col) {
            // Check if the cell is already split - using fast lookup
            const cellAlreadySplit = isCellSplit(currentPageIndex, row, col);

            if (cellAlreadySplit) {
                try {
                    // Find the index of the split cell in the array
                    const splitCellIndex = splitCells.findIndex(splitCell =>
                        splitCell.page === currentPageIndex &&
                        splitCell.row === row &&
                        splitCell.col === col
                    );

                    // Remove the cell from the splitCells array
                    if (splitCellIndex !== -1) {
                        splitCells.splice(splitCellIndex, 1);
                    }

                    // Get the current cell data (object with top and bottom)
                    const cellData = pages[currentPageIndex].data[row][col];

                    // Convert the cell data back to a string (use top value)
                    pages[currentPageIndex].data[row][col] = (typeof cellData === 'object' && cellData.top !== undefined)
                        ? cellData.top
                        : '';

                    // Update lookup tables
                    rebuildLookupTables();
                    
                    // Rebuild the grid to reflect the changes
                    createGrid();
                    saveToLocalStorage();
                } catch (error) {
                    console.error("Error during merge operation:", error);
                }

                return;
            }

            // Get the current value
            const currentValue = pages[currentPageIndex].data[row][col];

            // Create a new data structure for the split cell
            pages[currentPageIndex].data[row][col] = {
                top: typeof currentValue === 'object' ? currentValue.top : currentValue,
                bottom: ''
            };

            // Add to split cells list
            splitCells.push({
                page: currentPageIndex,
                row: row,
                col: col
            });
            
            // Update lookup tables
            rebuildLookupTables();

            // Rebuild the grid to reflect the changes
            createGrid();
            saveToLocalStorage();
        }

        // Handle order mode click
        function handleOrderModeClick(cell, row, col, cellValue) {
            // Check if already in order list - using fast lookup
            const orderIndex = isInOrderList(currentPageIndex, row, col) ? 
                orderLookup[`${currentPageIndex}-${row}-${col}`] : -1;

            if (orderIndex === -1) {
                // Add to order list
                const newItem = {
                    page: currentPageIndex,
                    pageName: pages[currentPageIndex].name,
                    row,
                    col,
                    value: cellValue
                };

                orderItems.push(newItem);
                cell.classList.add('selected');

                const orderNumber = document.createElement('div');
                orderNumber.className = 'order-number';
                orderNumber.textContent = orderItems.length;
                cell.appendChild(orderNumber);
                
                // Update lookup tables
                rebuildLookupTables();
                saveToLocalStorage();

                // Update panel
                if (els.orderPanel.classList.contains('show')) {
                    updateOrderPanel();
                }
            } else {
                // Remove from order list
                orderItems.splice(orderIndex, 1);

                // Find and remove the corresponding item in the order panel
                const panelItem = document.querySelector(`.order-panel-item[data-row="${row}"][data-col="${col}"]:not([data-part])`);
                if (panelItem && panelItem.parentNode) {
                    // Remove item immediately without animation
                    panelItem.parentNode.removeChild(panelItem);
                }

                // Only remove selected class if no expiration
                if (!isInExpirationList(currentPageIndex, row, col)) {
                    cell.classList.remove('selected');
                    cell.style.backgroundColor = '';
                }

                // Remove order number
                const orderNumbers = cell.querySelectorAll('.order-number');
                orderNumbers.forEach(num => {
                    if (num.textContent !== "ðŸ“†") {
                        cell.removeChild(num);
                    }
                });
                
                // Update lookup tables
                rebuildLookupTables();
                updateOrderNumbers();
                saveToLocalStorage();

                // Update panel
                if (els.orderPanel.classList.contains('show')) {
                    updateOrderPanel();
                }
            }
        }

        // Handle expiration mode click
        function handleExpirationModeClick(cell, row, col, cellValue) {
            // Check if already has expiration - using fast lookup
            const expirationIndex = isInExpirationList(currentPageIndex, row, col) ?
                expirationLookup[`${currentPageIndex}-${row}-${col}`] : -1;

            if (expirationIndex === -1) {
                // Show date modal for this cell
                showDateModal(cell, row, col, null, cellValue);
            } else {
                // Remove from expiration list
                expirationItems.splice(expirationIndex, 1);
                
                // Update lookup tables
                rebuildLookupTables();
                saveToLocalStorage();

                // Only remove styling if no order
                if (!isInOrderList(currentPageIndex, row, col)) {
                    cell.style.backgroundColor = '';
                    cell.classList.remove('selected');
                }

                // Remove expiration markers
                const markers = cell.querySelectorAll('.order-number');
                markers.forEach(marker => {
                    if (marker.textContent === "ðŸ“†") {
                        cell.removeChild(marker);
                    }
                });

                updateExpirationPanel();
            }
        }
        
        // Create dropdown options
        function populateDropdown() {
            els.pageDropdown.innerHTML = '';
            const fragment = document.createDocumentFragment();

            pages.forEach((page, i) => {
                const option = document.createElement('div');
                option.className = 'page-option';
                option.textContent = page.name;
                option.dataset.index = i;

                option.addEventListener('click', function(e) {
                    e.stopPropagation();
                    currentPageIndex = parseInt(this.dataset.index, 10);
                    els.currentPage.textContent = pages[currentPageIndex].name;
                    els.pageDropdown.classList.remove('show');
                    createGrid();
                    saveToLocalStorage();
                });

                fragment.appendChild(option);
            });
            
            els.pageDropdown.appendChild(fragment);
        }

        // Edit button is removed, so this event listener is no longer needed

        // Toggle order mode
        els.orderToggle.addEventListener('click', function() {
            if (orderMode) {
                setActiveMode('none');
            } else {
                setActiveMode('order');
            }
        });

        // Toggle split cell mode
        els.splitCellButton.addEventListener('click', function() {
            if (splitCellMode) {
                setActiveMode('none');
            } else {
                setActiveMode('split');
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            if (els.pageDropdown) els.pageDropdown.classList.remove('show');
            if (els.bcDropdown) els.bcDropdown.classList.remove('show');
        });

        // Close panel when clicking X
        els.orderPanelClose.addEventListener('click', function() {
            setActiveMode('none');
        });

        // Function to clear expiration visual indicators
        function clearExpirationVisualIndicators() {
            // Find all cells with expiration indicators and remove them
            document.querySelectorAll('.cell, .subcell').forEach(cell => {
                const expirationLabel = cell.querySelector('.order-number');
                if (expirationLabel && expirationLabel.textContent === "ðŸ“†") {
                    cell.removeChild(expirationLabel);
                    
                    // Only remove background if no other selection
                    const hasOrder = cell.classList.contains('selected');
                    if (!hasOrder) {
                        cell.style.backgroundColor = "";
                    }
                }
            });
        }

        // Function to restore expiration visual indicators
        function restoreExpirationVisualIndicators() {
            if (!expirationMode) return;

            // Optimized with fast lookups for current page items only
            for (const key in expirationLookup) {
                const parts = key.split('-');
                const page = parseInt(parts[0]);
                
                // Skip if not on current page
                if (page !== currentPageIndex) continue;
                
                const row = parseInt(parts[1]);
                const col = parseInt(parts[2]);
                const part = parts[3];
                const index = expirationLookup[key];
                const item = expirationItems[index];

                // Find the cell or subcell
                let targetCell;
                if (part) {
                    targetCell = document.querySelector(
                        `.subcell[data-row="${row}"][data-col="${col}"][data-part="${part}"]`
                    );
                } else {
                    targetCell = document.querySelector(
                        `.cell[data-row="${row}"][data-col="${col}"]:not(.split)`
                    );
                }

                if (targetCell) {
                    // Set background color based on expiration status
                    if (isItemExpired(item)) {
                        targetCell.style.backgroundColor = "var(--expired-bg)";
                    } else if (isItemDueSoon(item)) {
                        targetCell.style.backgroundColor = "var(--soon-bg)";
                    }

                    // Add calendar icon if it doesn't exist
                    const existingIcon = targetCell.querySelector('.order-number[textContent="ðŸ“†"]');
                    if (!existingIcon) {
                        const expirationLabel = document.createElement('div');
                        expirationLabel.className = 'order-number';
                        expirationLabel.textContent = "ðŸ“†";
                        expirationLabel.title = item.expirationDate;
                        expirationLabel.style.backgroundColor = isItemExpired(item) ? 
                            "var(--red-color)" : "var(--yellow-color)";
                        targetCell.appendChild(expirationLabel);
                    }
                }
            }
        }

        // Function to start the rename process
        function startRenaming() {
            if (isRenaming) return;
            isRenaming = true;

            // Cache important elements
            const pageSelector = document.querySelector('.page-selector');
            const originalContent = pageSelector.innerHTML;

            pageSelector.innerHTML = '';

            const label = document.createElement('span');
            label.className = 'page-label';
            label.textContent = 'New name:';

            const input = document.createElement('input');
            input.className = 'rename-input';
            input.value = pages[currentPageIndex].name;

            // Store original value to detect changes
            const originalValue = input.value;

            function saveName() {
                // Only save if the value has changed
                if (input.value !== originalValue) {
                    pages[currentPageIndex].name = input.value;

                    // Update page names in items - batch update for performance
                    const newPageName = input.value;
                    
                    orderItems.forEach(item => {
                        if (item.page === currentPageIndex) {
                            item.pageName = newPageName;
                        }
                    });

                    expirationItems.forEach(item => {
                        if (item.page === currentPageIndex) {
                            item.pageName = newPageName;
                        }
                    });

                    saveToLocalStorage();
                }
            }

            function restorePageSelector() {
                pageSelector.innerHTML = originalContent;
                // Re-fetch the DOM elements after restoring the HTML
                els.currentPage = document.getElementById('currentPage');
                els.pageDropdown = document.getElementById('pageDropdown');
                els.currentPage.textContent = pages[currentPageIndex].name;
                setupDropdownToggle();
                isRenaming = false;
            }

            // Save when focus leaves the input field
            input.addEventListener('blur', function() {
                saveName();
                restorePageSelector();
                populateDropdown();
            });

            // Handle keyboard events (Enter to save, Escape to cancel)
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    saveName();
                    restorePageSelector();
                    populateDropdown();
                } else if (e.key === 'Escape') {
                    // Cancel without saving
                    restorePageSelector();
                }
            });

            pageSelector.append(label, input);
            input.focus();
            // Select all text for easy editing
            input.select();
        }

        // Global state to track if any order operation is in progress
        // This prevents multiple operations from conflicting
        let isProcessingOrderOperation = false;

        // Helper function to create a panel item - completely overhauled
        function createPanelItem(item, index) {
            const orderItem = document.createElement('div');
            orderItem.className = 'order-panel-item';

            const itemNumber = document.createElement('span');
            itemNumber.className = 'item-number';
            itemNumber.textContent = (index + 1);

            // Create container for item info to allow for better formatting
            const itemTextContainer = document.createElement('div');
            itemTextContainer.style.display = 'flex';
            itemTextContainer.style.flexDirection = 'column';
            itemTextContainer.style.flexGrow = '1';

            // Main item text
            const itemText = document.createElement('span');

            // Get the latest cell data and value from the pages array
            const cellData = pages[item.page].data[item.row][item.col];
            let cellValue;
            let bcValue = null;

            if (item.part) {
                // Subcell - get the latest value and BC value for this part
                if (typeof cellData === 'object') {
                    cellValue = cellData[item.part] || '';
                    // Check for BC in bcValues
                    if (cellData.bcValues && cellData.bcValues[item.part]) {
                        bcValue = cellData.bcValues[item.part];
                    }
                } else {
                    cellValue = '';
                }
            } else {
                // Regular cell - get the latest value and BC value
                if (typeof cellData === 'object') {
                    if (cellData.hasOwnProperty('value')) {
                        cellValue = cellData.value;
                    } else if (cellData.hasOwnProperty('top')) {
                        cellValue = cellData.top;
                    } else {
                        cellValue = '';
                    }

                    // Check for bcValue property
                    if (cellData.bcValue) {
                        bcValue = cellData.bcValue;
                    }
                } else {
                    cellValue = cellData || '';
                }
            }

            // Use the most up-to-date value from the grid data
            const displayValue = cellValue || item.value || '';

            // Display with BC value if present
            if (bcValue) {
                itemText.innerHTML = `${item.pageName}: <span style="font-weight: bold">${displayValue}</span> <span style="color: var(--green-color); font-weight: bold">BC ${bcValue}</span>`;
            } else {
                itemText.textContent = `${item.pageName}: ${displayValue}`;
            }

            itemTextContainer.appendChild(itemText);

            orderItem.appendChild(itemNumber);
            orderItem.appendChild(itemTextContainer);

            // Store original item data and index for easier reference
            orderItem.dataset.itemIndex = index;
            orderItem.dataset.row = item.row;
            orderItem.dataset.col = item.col;
            if (item.part) {
                orderItem.dataset.part = item.part;
            }

            // Completely overhauled click handler for better responsiveness
            orderItem.addEventListener('click', handleOrderItemClick);

            return orderItem;
        }

            // Separated click handler function for order panel items
            // This significantly improves maintainability and allows for global state management
            function handleOrderItemClick(event) {
                event.preventDefault();
                event.stopPropagation();

                // Just disable pointer events to prevent further clicks
                this.style.pointerEvents = "none";

                try {
                    // Get the basic data for this item
                    const currentIdx = parseInt(this.dataset.itemIndex);
                    const itemRow = parseInt(this.dataset.row);
                    const itemCol = parseInt(this.dataset.col);
                    const itemPart = this.dataset.part;
                    
                    // Remove from data structure immediately
                    if (currentIdx >= 0 && currentIdx < orderItems.length) {
                        orderItems.splice(currentIdx, 1);
                    }
                    
                    // Remove from DOM immediately
                    if (this.parentNode) {
                        this.parentNode.removeChild(this);
                    }
                    
                    // Update lookup tables and refresh grid
                    rebuildLookupTables();
                    forceGridRefresh();
                    
                    // Save changes to localStorage
                    saveToLocalStorage();
                } catch (error) {
                    console.error("Error in order item click handler:", error);
                    createGrid();
                    updateOrderPanel();
                }
                
                return false; // Prevent event bubbling
            }
        
        // New function to force a complete grid refresh - more reliable than updateOrderNumbers
        function forceGridRefresh() {
            // For an empty order list, just reset everything
            if (orderItems.length === 0) {
                resetAllGridHighlighting();
                updateOrderPanel();
                return;
            }
            
            // First remove all order numbers and clean up cells that should no longer be highlighted
            removeAllOrderNumbers();
            
            // Now correctly apply order numbers to all cells in current page
            applyOrderNumbersToGrid();
            
            // Update the order panel if it's visible
            if (els.orderPanel.classList.contains('show')) {
                updateOrderPanel();
            }
        }
        
        // Helper to remove all order numbers from the grid
        function removeAllOrderNumbers() {
            document.querySelectorAll('.cell, .subcell').forEach(el => {
                // Get row, col, and part data from the element
                const row = parseInt(el.dataset.row);
                const col = parseInt(el.dataset.col);
                const part = el.dataset.part;
                
                if (isNaN(row) || isNaN(col)) return; // Skip elements without proper data
                
                // Find and remove order numbers (not expiration markers)
                const orderNumbers = Array.from(el.querySelectorAll('.order-number'))
                    .filter(num => num.textContent !== "ðŸ“†");
                
                orderNumbers.forEach(num => {
                    try {
                        el.removeChild(num);
                    } catch (e) {
                        console.error("Error removing order number:", e);
                    }
                });
                
                // Check if this element should still be highlighted
                const hasOrder = isInOrderList(currentPageIndex, row, col, part);
                const hasExpiration = isInExpirationList(currentPageIndex, row, col, part);
                
                // If no highlighting is needed, remove selected class and background
                if (!hasOrder && !hasExpiration) {
                    el.classList.remove('selected');
                    el.style.backgroundColor = '';
                }
            });
        }
        
        // Helper to apply current order numbers to the grid
        function applyOrderNumbersToGrid() {
            // For each order item, find its cell on the current page and update
            orderItems.forEach((item, index) => {
                // Skip items not on the current page
                if (item.page !== currentPageIndex) return;
                
                let targetEl;
                
                // Find the appropriate cell or subcell
                if (item.part) {
                    targetEl = document.querySelector(
                        `.subcell[data-row="${item.row}"][data-col="${item.col}"][data-part="${item.part}"]`
                    );
                } else {
                    targetEl = document.querySelector(
                        `.cell[data-row="${item.row}"][data-col="${item.col}"]:not(.split)`
                    );
                }
                
                // If found, update its appearance
                if (targetEl) {
                    // Ensure it has the selected class
                    targetEl.classList.add('selected');
                    
                    // Create and add the order number
                    const orderNumber = document.createElement('div');
                    orderNumber.className = 'order-number';
                    orderNumber.textContent = index + 1;
                    targetEl.appendChild(orderNumber);
                }
            });
        }

        // Helper function to create an expiration panel item
        function createExpirationPanelItem(item, index) {
            const expirationItem = document.createElement('div');
            expirationItem.className = 'order-panel-item';

            // Add styling based on expiration status
            if (isItemExpired(item)) {
                expirationItem.style.borderLeft = '4px solid var(--red-color)';
            } else if (isItemDueSoon(item)) {
                expirationItem.style.borderLeft = '4px solid var(--yellow-color)';
            }

            const itemNumber = document.createElement('span');
            itemNumber.className = 'item-number';
            itemNumber.textContent = "ðŸ“†";
            itemNumber.style.backgroundColor = isItemExpired(item) ? 
                "var(--red-color)" : "var(--yellow-color)";

            const itemText = document.createElement('span');
            itemText.innerHTML = `<strong>${item.expirationDate}</strong> - ${item.pageName}: ${item.value}`;

            expirationItem.appendChild(itemNumber);
            expirationItem.appendChild(itemText);

            // Store data attributes
            expirationItem.dataset.row = item.row;
            expirationItem.dataset.col = item.col;
            expirationItem.dataset.index = index;
            if (item.part) {
                expirationItem.dataset.part = item.part;
            }

            // Add click handler to remove this item
            expirationItem.addEventListener('click', function() {
                // Disable pointer events to prevent multiple clicks
                this.style.pointerEvents = "none";
                
                const idx = parseInt(this.dataset.index);
                
                // Check bounds before removing
                if (idx >= 0 && idx < expirationItems.length) {
                    // Remove from expiration list
                    expirationItems.splice(idx, 1);
                    
                    // Update lookup tables
                    rebuildLookupTables();
                    saveToLocalStorage();

                    // If on current page, update the cell
                    if (item.page === currentPageIndex) {
                        let targetCell;
                        if (item.part) {
                            targetCell = document.querySelector(
                                `.subcell[data-row="${item.row}"][data-col="${item.col}"][data-part="${item.part}"]`
                            );
                        } else {
                            targetCell = document.querySelector(
                                `.cell[data-row="${item.row}"][data-col="${item.col}"]:not(.split)`
                            );
                        }
                        
                        if (targetCell) {
                            // Check if there's an order for this cell
                            const hasOrder = isInOrderList(
                                currentPageIndex, 
                                parseInt(item.row), 
                                parseInt(item.col), 
                                item.part
                            );
                            
                            if (!hasOrder) {
                                targetCell.classList.remove('selected');
                                targetCell.style.backgroundColor = '';
                            }
                            
                            // Remove only expiration markers
                            const expirationMarkers = Array.from(targetCell.querySelectorAll('.order-number'))
                                .filter(marker => marker.textContent === "ðŸ“†");
                                
                            expirationMarkers.forEach(marker => targetCell.removeChild(marker));
                        }
                    }
                }
                
                // Remove item immediately without animation
                if (this.parentNode) {
                    this.parentNode.removeChild(this);
                    updateExpirationPanel();
                }
            });

            return expirationItem;
        }

        // Helper function to create expiration panel items for the order panel
        function createExpirationPanelItemForOrder(item) {
            const expirationItem = document.createElement('div');
            expirationItem.className = 'order-panel-item';

            // Style based on expiration status
            if (isItemExpired(item)) {
                expirationItem.style.borderLeft = '4px solid var(--red-color)';
            } else if (isItemDueSoon(item)) {
                expirationItem.style.borderLeft = '4px solid var(--yellow-color)';
            }

            const itemNumber = document.createElement('span');
            itemNumber.className = 'item-number';
            itemNumber.textContent = "ðŸ“†";
            itemNumber.style.backgroundColor = isItemExpired(item) ? 
                "var(--red-color)" : "var(--yellow-color)";

            const itemText = document.createElement('span');
            itemText.innerHTML = `<strong>${item.expirationDate}</strong> - ${item.pageName}: ${item.value}`;

            expirationItem.appendChild(itemNumber);
            expirationItem.appendChild(itemText);

            // Store data attributes
            expirationItem.dataset.row = item.row;
            expirationItem.dataset.col = item.col;
            if (item.part) {
                expirationItem.dataset.part = item.part;
            }
            expirationItem.dataset.isExpiration = "true";

            // Optimized click handler to delete item
            expirationItem.addEventListener('click', function() {
                // Disable pointer events to prevent multiple clicks
                this.style.pointerEvents = "none";

                // Find indices in respective arrays
                let orderIndex = -1;
                let expirationIndex = -1;
                
                const row = parseInt(this.dataset.row);
                const col = parseInt(this.dataset.col);
                const part = this.dataset.part;
                
                // Use lookup tables for fast index retrieval
                const orderKey = `${currentPageIndex}-${row}-${col}${part ? '-' + part : ''}`;
                const expirationKey = orderKey;
                
                orderIndex = orderLookup[orderKey] !== undefined ? orderLookup[orderKey] : -1;
                expirationIndex = expirationLookup[expirationKey] !== undefined ? expirationLookup[expirationKey] : -1;

                // Remove from collections if found
                if (orderIndex !== -1) {
                    orderItems.splice(orderIndex, 1);
                }
                
                if (expirationIndex !== -1) {
                    expirationItems.splice(expirationIndex, 1);
                }
                
                // Update lookup tables
                rebuildLookupTables();
                saveToLocalStorage();

                // Update cell if we're on the same page
                if (item.page === currentPageIndex) {
                    let targetCell;
                    if (part) {
                        // Find subcell
                        targetCell = document.querySelector(
                            `.subcell[data-row="${row}"][data-col="${col}"][data-part="${part}"]`
                        );
                    } else {
                        // Find regular cell
                        targetCell = document.querySelector(
                            `.cell[data-row="${row}"][data-col="${col}"]:not(.split)`
                        );
                    }

                    if (targetCell) {
                        // Update visuals - check if any reason to keep highlighting
                        const hasOtherOrder = isInOrderList(currentPageIndex, row, col, part);
                        const hasOtherExpiration = isInExpirationList(currentPageIndex, row, col, part);

                        if (!hasOtherOrder && !hasOtherExpiration) {
                            targetCell.classList.remove('selected');
                            targetCell.style.backgroundColor = '';
                        }

                        // Remove markers
                        const markers = targetCell.querySelectorAll('.order-number');
                        markers.forEach(marker => {
                            if (marker.textContent === "ðŸ“†" ||
                                (orderIndex !== -1 && marker.textContent === (orderIndex + 1).toString())) {
                                targetCell.removeChild(marker);
                            }
                        });
                    }
                }
                
                // Remove item immediately without animation
                if (this.parentNode) {
                    this.parentNode.removeChild(this);
                    updateOrderPanel();
                    updateOrderNumbers();
                }
            });

            return expirationItem;
        }

        // Function to update the order panel content - optimized with document fragments
        function updateOrderPanel() {
            els.orderPanelItems.innerHTML = '';
            const fragment = document.createDocumentFragment();

            // Combined array for both order items and expiring items
            let displayItems = [];

            // Add all manually ordered items
            displayItems = [...orderItems];

            // Add expiring items (if they're not already in the order list)
            const expiredAndSoonItems = expirationItems.filter(item =>
                isItemExpired(item) || isItemDueSoon(item)
            );

            // Check if expiring items are already in the order list to avoid duplicates
            expiredAndSoonItems.forEach(expItem => {
                // Use lookup table for fast checking
                const key = getItemKey(expItem);
                if (orderLookup[key] === undefined) {
                    // Add a special flag to indicate this is an expiration item
                    const displayItem = { ...expItem, isExpirationItem: true };
                    displayItems.push(displayItem);
                }
            });

            if (displayItems.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'order-panel-empty';
                emptyMessage.textContent = 'No items ordered';
                fragment.appendChild(emptyMessage);
            } else {
                // First show manually ordered items
                const manuallyOrderedItems = displayItems.filter(item => !item.isExpirationItem);
                if (manuallyOrderedItems.length > 0) {
                    const orderedHeader = document.createElement('div');
                    orderedHeader.className = 'section-header';
                    orderedHeader.textContent = 'Ordered Items';
                    orderedHeader.style.backgroundColor = '#e2e3e5';
                    orderedHeader.style.color = '#383d41';
                    fragment.appendChild(orderedHeader);

                    // Create and add each order item to the panel
                    manuallyOrderedItems.forEach((item, index) => {
                        const orderItem = createPanelItem(item, index);
                        fragment.appendChild(orderItem);
                    });
                }

                // Then show expired items
                const expiredItems = displayItems.filter(item =>
                    item.isExpirationItem && isItemExpired(item)
                );
                if (expiredItems.length > 0) {
                    const expiredHeader = document.createElement('div');
                    expiredHeader.className = 'section-header expired-header';
                    expiredHeader.textContent = 'Expired Items';
                    fragment.appendChild(expiredHeader);

                    expiredItems.forEach(item => {
                        const expirationItem = createExpirationPanelItemForOrder(item);
                        fragment.appendChild(expirationItem);
                    });
                }

                // Then show items expiring soon
                const soonItems = displayItems.filter(item =>
                    item.isExpirationItem && !isItemExpired(item) && isItemDueSoon(item)
                );
                if (soonItems.length > 0) {
                    const soonHeader = document.createElement('div');
                    soonHeader.className = 'section-header soon-header';
                    soonHeader.textContent = 'Expiring Soon';
                    fragment.appendChild(soonHeader);

                    soonItems.forEach(item => {
                        const expirationItem = createExpirationPanelItemForOrder(item);
                        fragment.appendChild(expirationItem);
                    });
                }
            }
            
            els.orderPanelItems.appendChild(fragment);
        }

        // Helper function to check if an item is expired - optimized with date caching
        function isItemExpired(item) {
            if (!item.expirationDate) return false;
            
            // Cache current date at function level for better performance when calling multiple times
            const now = new Date();
            const [month, year] = item.expirationDate.split('/');
            const expirationDate = new Date(parseInt(year), parseInt(month) - 1, 1);
            return now >= expirationDate;
        }

        // Helper function to check if an item is due soon (within 2 months) - optimized with date caching
        function isItemDueSoon(item) {
            if (!item.expirationDate) return false;
            
            // Cache current date and future threshold at function level
            const now = new Date();
            const [month, year] = item.expirationDate.split('/');
            const expirationDate = new Date(parseInt(year), parseInt(month) - 1, 1);

            // Calculate two months from now
            const twoMonthsFromNow = new Date(now);
            twoMonthsFromNow.setMonth(now.getMonth() + 2);

            return now < expirationDate && expirationDate <= twoMonthsFromNow;
        }

        // Function to update the expiration panel content
        function updateExpirationPanel() {
            els.orderPanelItems.innerHTML = '';
            const fragment = document.createDocumentFragment();

            if (expirationItems.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'order-panel-empty';
                emptyMessage.textContent = 'No expiration dates set';
                fragment.appendChild(emptyMessage);
                els.orderPanelItems.appendChild(fragment);
                return;
            }

            // Sort items by expiration date (closest first)
            const sortedItems = [...expirationItems].sort((a, b) => {
                const [aMonth, aYear] = a.expirationDate.split('/');
                const [bMonth, bYear] = b.expirationDate.split('/');

                if (aYear !== bYear) return parseInt(aYear) - parseInt(bYear);
                return parseInt(aMonth) - parseInt(bMonth);
            });

            // First show expired items
            const expiredItems = sortedItems.filter(item => isItemExpired(item));
            if (expiredItems.length > 0) {
                const expiredHeader = document.createElement('div');
                expiredHeader.className = 'section-header expired-header';
                expiredHeader.textContent = 'Expired Items';
                fragment.appendChild(expiredHeader);

                expiredItems.forEach(item => {
                    const index = expirationItems.indexOf(item);
                    const panelItem = createExpirationPanelItem(item, index);
                    fragment.appendChild(panelItem);
                });
            }

            // Then show items expiring soon
            const dueSoonItems = sortedItems.filter(item => !isItemExpired(item) && isItemDueSoon(item));
            if (dueSoonItems.length > 0) {
                const dueSoonHeader = document.createElement('div');
                dueSoonHeader.className = 'section-header soon-header';
                dueSoonHeader.textContent = 'Expiring Soon';
                fragment.appendChild(dueSoonHeader);

                dueSoonItems.forEach(item => {
                    const index = expirationItems.indexOf(item);
                    const panelItem = createExpirationPanelItem(item, index);
                    fragment.appendChild(panelItem);
                });
            }
            
            els.orderPanelItems.appendChild(fragment);
        }

        // Completely reset grid cell highlighting
        function resetAllGridHighlighting() {
            // Reset all cells and subcells to their base state
            document.querySelectorAll('.cell, .subcell').forEach(el => {
                el.classList.remove('selected');

                // Check if this has an expiration marker
                const hasExpiration = el.querySelector('.order-number[textContent="ðŸ“†"]');

                if (!hasExpiration) {
                    el.style.backgroundColor = '';
                }

                // Remove only order number markers (not expiration)
                const orderNumbers = Array.from(el.querySelectorAll('.order-number'))
                    .filter(num => num.textContent !== "ðŸ“†");

                orderNumbers.forEach(num => el.removeChild(num));
            });
        }

        // Enhanced version of updateOrderNumbers that's more reliable during rapid interactions
        function updateOrderNumbers() {
            try {
                // Use the force refresh method which is more reliable
                forceGridRefresh();
            } catch (error) {
                console.error("Error in updateOrderNumbers:", error);
                // As a fallback, recreate the entire grid
                createGrid();
            }
        }

        // Show the date input modal (updated to handle subcells)
        function showDateModal(cell, row, col, part, value) {
            // Reset modal selections
            els.monthSelect.selectedIndex = 0;
            els.yearSelect.selectedIndex = 0;
            els.confirmDateBtn.disabled = true;

            // Save reference to the current cell and its data
            currentCell = cell;
            currentCellData = { row, col, part, value };

            // Show the modal
            els.dateModalOverlay.style.display = 'flex';
        }

        // Handle dropdown changes
        els.monthSelect.addEventListener('change', validateDateInputs);
        els.yearSelect.addEventListener('change', validateDateInputs);

        // Validation for dropdowns
        function validateDateInputs() {
            const month = els.monthSelect.value;
            const year = els.yearSelect.value;

            // Enable confirm button only if both are selected
            els.confirmDateBtn.disabled = !month || !year;
        }

        // Handle confirm button click for expiration
        els.confirmDateBtn.addEventListener('click', function() {
            const month = els.monthSelect.value;
            const year = els.yearSelect.value;

            // Simple validation
            if (!month || !year) {
                return;
            }

            const expirationDate = `${month}/${year}`;

            // Create the new expiration item with part if it's a subcell
            const newItem = {
                page: currentPageIndex,
                pageName: pages[currentPageIndex].name,
                row: currentCellData.row,
                col: currentCellData.col,
                value: currentCellData.value,
                expirationDate: expirationDate
            };

            // Add part information if this is a subcell
            if (currentCellData.part) {
                newItem.part = currentCellData.part;
            }

            // Add to expiration list
            expirationItems.push(newItem);
            
            // Update lookup tables
            rebuildLookupTables();

            // Set the background color based on expiration status
            if (isItemExpired(newItem)) {
                currentCell.style.backgroundColor = "var(--expired-bg)";
            } else if (isItemDueSoon(newItem)) {
                currentCell.style.backgroundColor = "var(--soon-bg)";
            }

            // Add expiration label if in expiration mode
            if (expirationMode) {
                const expirationLabel = document.createElement('div');
                expirationLabel.className = 'order-number';
                expirationLabel.textContent = "ðŸ“†";
                expirationLabel.title = expirationDate;
                expirationLabel.style.backgroundColor = isItemExpired(newItem) ? 
                    "var(--red-color)" : "var(--yellow-color)";
                currentCell.appendChild(expirationLabel);
            }

            // Update expiration panel
            updateExpirationPanel();
            saveToLocalStorage();

            // Hide modal
            els.dateModalOverlay.style.display = 'none';
        });

        // Handle cancel button click
        els.cancelDateBtn.addEventListener('click', function() {
            els.dateModalOverlay.style.display = 'none';
        });

        // Close modal when clicking outside
        els.dateModalOverlay.addEventListener('click', function(e) {
            if (e.target === els.dateModalOverlay) {
                els.dateModalOverlay.style.display = 'none';
            }
        });

        // Handle keyboard events for modals
        document.addEventListener('keydown', function(e) {
            if (els.dateModalOverlay.style.display === 'flex') {
                if (e.key === 'Escape') {
                    els.dateModalOverlay.style.display = 'none';
                } else if (e.key === 'Enter' && !els.confirmDateBtn.disabled) {
                    els.confirmDateBtn.click();
                }
            } else if (els.formatModalOverlay.style.display === 'flex') {
                if (e.key === 'Escape') {
                    els.formatModalOverlay.style.display = 'none';
                } else if (e.key === 'Enter' && !els.confirmFormatBtn.disabled) {
                    els.confirmFormatBtn.click();
                }
            }
        });

        // Format a number to the required +/-x.xx format
        function formatValue(value) {
            // Ensure value is within range (-12.00 to +12.00)
            value = Math.max(-12, Math.min(12, value));

            // Format to 2 decimal places
            const formatted = value.toFixed(2);

            // Add + sign for positive numbers
            return value >= 0 ? `+${formatted}` : formatted;
        }

        // Update both display and input field
        function updateValueDisplay() {
            const formattedValue = formatValue(currentValueNum);
            els.valueDisplay.textContent = formattedValue;
            els.formatInput.value = formattedValue;

            // Always enable confirm button as values are controlled
            els.confirmFormatBtn.disabled = false;
        }

        // Increment button handler
        els.incrementBtn.addEventListener('click', function() {
            // Increment by 0.25 and limit to +12.00
            currentValueNum = Math.min(12, currentValueNum + 0.25);
            updateValueDisplay();
        });

        // Toggle BC dropdown
        els.bcBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            els.bcDropdown.classList.toggle('show');
        });

        // Handle BC option selection
        document.querySelectorAll('.bc-option').forEach(option => {
            option.addEventListener('click', function() {
                // Store the BC value separately from the main value
                currentBCValue = this.dataset.value;

                // Visual feedback that BC was selected
                els.bcBtn.style.backgroundColor = "var(--green-color)";
                els.bcBtn.style.color = "white";
                els.bcBtn.textContent = `BC ${currentBCValue}`;

                els.bcDropdown.classList.remove('show');
            });
        });

        // Decrement button handler
        els.decrementBtn.addEventListener('click', function() {
            // Decrement by 0.25 and limit to -12.00
            currentValueNum = Math.max(-12, currentValueNum - 0.25);
            updateValueDisplay();
        });

        // Show format modal for Edit mode
        function showFormatModal(cell, row, col, part = null) {
            // Reset error message
            els.formatError.style.display = 'none';

            // Get current value
            let currentValue = '';
            if (part) {
                if (typeof pages[currentPageIndex].data[row][col] === 'object') {
                    currentValue = pages[currentPageIndex].data[row][col][part] || '';
                }
            } else {
                if (typeof pages[currentPageIndex].data[row][col] === 'object') {
                    currentValue = pages[currentPageIndex].data[row][col].top || '';
                } else {
                    currentValue = pages[currentPageIndex].data[row][col] || '';
                }
            }

            // Prefill with current value if it matches the format
            const formatRegex = /^[+-]\d+\.\d{2}$/;
            if (formatRegex.test(currentValue)) {
                // Parse the current value as a number for the increment/decrement functionality
                currentValueNum = parseFloat(currentValue);
            } else {
                // Default to 0 if no valid value
                currentValueNum = 0;
            }

            // Update display with current or default value
            updateValueDisplay();

            // Reset BC button
            els.bcBtn.style.backgroundColor = '';
            els.bcBtn.style.color = '';
            els.bcBtn.textContent = 'BC';
            currentBCValue = null;

            // Reset expiration fields
            els.formatExpirationMonth.selectedIndex = 0;
            els.formatExpirationYear.selectedIndex = 0;

            // Check if this cell already has an expiration date - using fast lookup
            const key = `${currentPageIndex}-${row}-${col}${part ? '-' + part : ''}`;
            const expirationIndex = expirationLookup[key] !== undefined ? expirationLookup[key] : -1;

            // If expiration date exists, set the fields
            if (expirationIndex !== -1) {
                const expirationItem = expirationItems[expirationIndex];
                const [month, year] = expirationItem.expirationDate.split('/');

                // Set the month dropdown
                for (let i = 0; i < els.formatExpirationMonth.options.length; i++) {
                    if (els.formatExpirationMonth.options[i].value === month) {
                        els.formatExpirationMonth.selectedIndex = i;
                        break;
                    }
                }

                // Set the year dropdown
                for (let i = 0; i < els.formatExpirationYear.options.length; i++) {
                    if (els.formatExpirationYear.options[i].value === year) {
                        els.formatExpirationYear.selectedIndex = i;
                        break;
                    }
                }
            }

            // Save reference to current cell and data
            currentCell = cell;
            currentCellData = { row, col, part };

            // Show the modal
            els.formatModalOverlay.style.display = 'flex';
            els.formatInput.focus();
        }

        // Confirm button handler for format modal
        els.confirmFormatBtn.addEventListener('click', function() {
            const value = els.formatInput.value;
            const row = currentCellData.row;
            const col = currentCellData.col;
            const part = currentCellData.part;

            // Update cell value and BC value
            if (part) {
                // This is a subcell
                if (typeof pages[currentPageIndex].data[row][col] !== 'object') {
                    pages[currentPageIndex].data[row][col] = {
                        top: '',
                        bottom: ''
                    };
                }

                // Set the main value for this part
                pages[currentPageIndex].data[row][col][part] = value;

                // Store BC value if selected
                if (currentBCValue) {
                    // Initialize bcValues object if it doesn't exist
                    if (!pages[currentPageIndex].data[row][col].bcValues) {
                        pages[currentPageIndex].data[row][col].bcValues = {};
                    }

                    // Store BC value for this part
                    pages[currentPageIndex].data[row][col].bcValues[part] = currentBCValue;
                }
            } else {
                // Regular cell
                // Convert to object structure if BC value is set
                if (currentBCValue) {
                    // If cell already has an object structure with "top" property, preserve it
                    if (typeof pages[currentPageIndex].data[row][col] === 'object' &&
                        pages[currentPageIndex].data[row][col].hasOwnProperty('top')) {

                        pages[currentPageIndex].data[row][col].top = value;
                        pages[currentPageIndex].data[row][col].bcValue = currentBCValue;
                    } else {
                        // Store as a value/bcValue pair
                        pages[currentPageIndex].data[row][col] = {
                            value: value,
                            bcValue: currentBCValue
                        };
                    }
                } else {
                    // No BC value, store as simple value (string) if not a split cell
                    if (typeof pages[currentPageIndex].data[row][col] === 'object' &&
                        pages[currentPageIndex].data[row][col].hasOwnProperty('top')) {
                        // This appears to be a split cell, update the top value
                        pages[currentPageIndex].data[row][col].top = value;
                    } else {
                        // Simple string value
                        pages[currentPageIndex].data[row][col] = value;
                    }
                }
            }

            // Handle expiration date fields
            const month = els.formatExpirationMonth.value;
            const year = els.formatExpirationYear.value;

            // Check if this cell already has an expiration date - using fast lookup
            const key = `${currentPageIndex}-${row}-${col}${part ? '-' + part : ''}`;
            const expirationIndex = expirationLookup[key] !== undefined ? expirationLookup[key] : -1;

            if (month && year) {
                // Month and year are set - add or update expiration date
                const expirationDate = `${month}/${year}`;

                if (expirationIndex !== -1) {
                    // Update existing expiration date
                    expirationItems[expirationIndex].expirationDate = expirationDate;
                    expirationItems[expirationIndex].value = value; // Update value too
                } else {
                    // Add new expiration date
                    const newItem = {
                        page: currentPageIndex,
                        pageName: pages[currentPageIndex].name,
                        row: row,
                        col: col,
                        value: value,
                        expirationDate: expirationDate
                    };

                    // Add part if it's a subcell
                    if (part) {
                        newItem.part = part;
                    }

                    expirationItems.push(newItem);
                }

                // Update lookup tables
                rebuildLookupTables();
                
                // Set visual indicator on the cell
                updateCellExpiration(currentCell, row, col, part);
            } else if (expirationIndex !== -1) {
                // No month/year but had previous expiration - remove it
                expirationItems.splice(expirationIndex, 1);
                
                // Update lookup tables
                rebuildLookupTables();

                // Remove expiration styling from cell
                removeCellExpiration(currentCell);
            }

            // Update display
            const input = currentCell.querySelector('input');
            if (input) {
                input.value = value;
            }

            // Save changes
            saveToLocalStorage();

            // Close modal
            els.formatModalOverlay.style.display = 'none';

            // If in expiration mode, update the panel
            if (expirationMode) {
                updateExpirationPanel();
            }
        });

        // Function to update cell expiration visual indicators
        function updateCellExpiration(cell, row, col, part) {
            // Find the expiration item using fast lookup
            const key = `${currentPageIndex}-${row}-${col}${part ? '-' + part : ''}`;
            const expirationIndex = expirationLookup[key] !== undefined ? expirationLookup[key] : -1;

            if (expirationIndex !== -1) {
                const expirationItem = expirationItems[expirationIndex];

                // Set background color based on expiration status
                if (isItemExpired(expirationItem)) {
                    cell.style.backgroundColor = "var(--expired-bg)";
                } else if (isItemDueSoon(expirationItem)) {
                    cell.style.backgroundColor = "var(--soon-bg)";
                }

                // Add calendar indicator to cell if in expiration mode
                if (expirationMode) {
                    // Remove any existing expiration indicator
                    const existingIndicator = cell.querySelector('.order-number[textContent="ðŸ“†"]');
                    if (existingIndicator) {
                        cell.removeChild(existingIndicator);
                    }

                    // Add the calendar icon
                    const expirationLabel = document.createElement('div');
                    expirationLabel.className = 'order-number';
                    expirationLabel.textContent = "ðŸ“†";
                    expirationLabel.title = expirationItem.expirationDate;
                    expirationLabel.style.backgroundColor = isItemExpired(expirationItem) ? 
                        "var(--red-color)" : "var(--yellow-color)";
                    cell.appendChild(expirationLabel);
                }
            }
        }

        // Function to remove cell expiration visual indicators
        function removeCellExpiration(cell) {
            // Only remove if no order
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const part = cell.dataset.part;

            // Use fast lookup for checking
            if (!isInOrderList(currentPageIndex, row, col, part)) {
                cell.style.backgroundColor = '';
            }

            // Remove expiration markers
            const markers = cell.querySelectorAll('.order-number');
            markers.forEach(marker => {
                if (marker.textContent === "ðŸ“†") {
                    cell.removeChild(marker);
                }
            });
        }

        // Cancel button handler for format modal
        els.cancelFormatBtn.addEventListener('click', function() {
            els.formatModalOverlay.style.display = 'none';
        });

        // Close format modal when clicking outside
        els.formatModalOverlay.addEventListener('click', function(e) {
            if (e.target === els.formatModalOverlay) {
                els.formatModalOverlay.style.display = 'none';
            }
        });

        // Function to toggle dark mode
        function toggleDarkMode() {
            darkMode = !darkMode;
            document.body.classList.toggle('dark-mode', darkMode);
            els.darkModeToggle.classList.toggle('active', darkMode);

            // Save dark mode preference
            localStorage.setItem(DARK_MODE_KEY, darkMode);
        }

        // Add event listener for dark mode toggle
        els.darkModeToggle.addEventListener('click', toggleDarkMode);

        // Add event listener for exit button - force close without confirmation
        document.getElementById('exitButton').addEventListener('click', function() {
            try {
                window.close();
                // No fallback message - just attempt to close
            } catch (e) {
                // Silent fail - no alert
            }
        });

        // Populate year dropdowns once during initialization
        function populateYearDropdowns() {
            const currentYear = new Date().getFullYear();
            const yearFragment = document.createDocumentFragment();
            const formatYearFragment = document.createDocumentFragment();
            
            for (let year = currentYear; year <= currentYear + 10; year++) {
                // Add to date modal year dropdown
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearFragment.appendChild(option);

                // Also add to the format modal year dropdown
                const formatOption = document.createElement('option');
                formatOption.value = year;
                formatOption.textContent = year;
                formatYearFragment.appendChild(formatOption);
            }
            
            els.yearSelect.appendChild(yearFragment);
            els.formatExpirationYear.appendChild(formatYearFragment);
        }

        // Load data on page initialization
        document.addEventListener('DOMContentLoaded', function() {
            loadFromLocalStorage();
            els.currentPage.textContent = pages[currentPageIndex].name;
            setupDropdownToggle();
            populateDropdown();
            populateYearDropdowns();
            createGrid();
            updateOrderPanel();

            // Load dark mode preference
            const savedDarkMode = localStorage.getItem(DARK_MODE_KEY);
            if (savedDarkMode === 'true') {
                darkMode = true;
                document.body.classList.add('dark-mode');
                els.darkModeToggle.classList.add('active');
            }
        });
    </script>
    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }
    </script>
</body>

</html>